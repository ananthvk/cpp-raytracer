#pragma once
#include "ray.hpp"
#include <iostream>
#include <ostream>
using namespace linalg::ostream_overloads;
class RegularCamera
{
  private:
    // A vector which represents the alignment of the camera
    vec3 up;
    // A vector which points to the right of the camera
    vec3 right;
    // The direction the camera is looking at
    vec3 direction;
    // Position of the camera
    vec3 position;
    // Distance between the camera and the viewport screen
    double focal_length;
    // FOV angle
    double fov;
    // Width of the image (in pixels)
    int image_width;
    // Height of the image (in pixels)
    int image_height;
    // Aspect ratio is width / height
    double aspect_ratio;
    // Width of the virtual viewport (in metres)
    double viewport_width;
    // Height of the virtual viewport (in metres)
    double viewport_height;
    // It is the horizontal spacing between two adjacent pixels in the viewport
    double delta_x;
    // It is the vertical spacing between two adjacent pixels in the viewport
    double delta_y;

  public:
    // Initializes the values to some sensible defaults for development
    RegularCamera(int image_width, int image_height);
    // Returns a ray which passes through a pixel at (row, col)
    // Note: pixels start from (0,0), which is the top left corner
    Ray get_ray(int row, int col);
    void debug_info(std::ostream &os);
};
#pragma once
#include "commons.hpp"

// A struct to represent colors
struct colorf
{
    double r;
    double g;
    double b;
    colorf() : r(0), g(0), b(0) {}
    colorf(double r, double g, double b) : r(r), g(g), b(b) {}
    static colorf from_rgb(int r, int g, int b)
    {
        return colorf((double)r / 255, (double)g / 255, (double)b / 255);
    }
};

// Performs linear interpolation between two colors
inline colorf lerp(colorf s, colorf e, float t)
{
    return colorf(lerp(s.r, e.r, t), lerp(s.g, e.g, t), lerp(s.b, e.b, t));
}

// Some commonly used colors
const colorf SKY_COLOR = colorf::from_rgb(135, 206, 235);
const colorf WHITE = colorf::from_rgb(255, 255, 255);
const colorf LIGHT_SKY = colorf::from_rgb(188, 227, 244);
const colorf RED = colorf(1, 0, 0);
const colorf GREEN = colorf(0, 1, 0);
const colorf BLUE = colorf(0, 0, 1);
const colorf BLACK = colorf(0, 0, 0);
#pragma once
#include "linalg.h"
constexpr double PI = 3.141592653589793238463;

// Function to perform linear interpolation
inline float lerp(float s, float e, float t) { return (1 - t) * s + t * e; }

using vec3 = linalg::vec<double, 3>;#pragma once
#include "colors.hpp"
#include "commons.hpp"
#include <assert.h>
#include <iostream>
#include <stdint.h>
#include <stdlib.h>
#include <string>
#include <vector>

const int CHANNELS = 3;
const double SCALE_FACTOR = 255.99;
// Pixels are represented in floating point format, with values from 0 to 1.0
// corresponding to 0 to 255
using image_row = std::vector<colorf>;
using image = std::vector<image_row>;
// Writes the floating point image data to the file after converting it to
// integer format.
void write_to_file(const std::string &filename, image img);
#pragma once
#include "commons.hpp"
#include "ray.hpp"
#include <vector>

class Object
{
  public:
    virtual std::vector<double> intersection(const Ray &ray) const = 0;
    virtual ~Object() {}
};

class Sphere : public Object
{
  private:
    vec3 center;
    double radius;

  public:
    Sphere();
    Sphere(vec3 center, double radius);
    std::vector<double> intersection(const Ray &ray) const;
};
#pragma once
#include <iomanip>
#include <iostream>
#include <stdio.h>

void progressbar_display(std::ostream &os, int value, int max_value, int width,
                         bool display_percent = true);

// Hide the cursor to prevent flickering when updating progressbar
inline void progressbar_hide_cursor() { printf("%s", "\033[?25l"); }

// Show the cursor
inline void progressbar_show_cursor() { printf("%s", "\033[?25h"); }#pragma once
#include "commons.hpp"
class Ray
{
  private:
    vec3 rorigin, rdirection;

  public:
    Ray();
    Ray(const vec3 &p, const vec3 &d, bool normalized = false);
    // Returns a unit vector in the direction of this ray
    vec3 direction() const;
    // Returns the starting point of this ray
    vec3 origin() const;
    // Returns a point on this ray at a distance t from the origin
    vec3 at(double t) const;
};#pragma once
#include "colors.hpp"
#include "commons.hpp"
#include "objects.hpp"
#include "ray.hpp"
#include <memory>

class Scene
{
  private:
    std::vector<std::shared_ptr<Object>> objects;

  public:
    Scene();
    // Returns the color of the ray in this scene
    colorf color_at(const Ray &ray, int row, int col, int image_width,
                    int image_height);
};#include "camera.hpp"

RegularCamera::RegularCamera(int image_width, int image_height)
    : image_width(image_width), image_height(image_height)
{
    up = vec3(0.0, 1.0, 0.0);
    right = vec3(1.0, 0.0, 0.0);
    // The camera faces the negative z axis
    direction = vec3(0.0, 0.0, -1.0);
    // The camera is at the origin
    position = vec3(0.0, 0.0, 0.0);
    // focal length of 1m
    focal_length = 1.0;
    // 90 degrees FOV
    fov = PI / 2.0;
    // 16:9 aspect ratio
    aspect_ratio = static_cast<double>(image_width) / image_height;
    // tan (theta/2) = h/(focal length).
    viewport_height = 2.0 * std::tan(fov / 2.0) * focal_length;
    viewport_width = aspect_ratio * viewport_height;
    delta_x = viewport_width / image_width;
    delta_y = viewport_height / image_height;
}

// Returns a ray which passes through a pixel at (row, col)
// Note: pixels start from (0,0), which is the top left corner
Ray RegularCamera::get_ray(int row, int col)
{
    // Find the other point on this ray, one end point is the position of
    // the camera.
    // In PCC (Pixel coordinate system), the center is represented as
    // image_width/2, image_height/2
    double x0 = std::max(image_width / 2.0, 1.0);
    double y0 = std::max(image_height / 2.0, 1.0);
    // x and y represent the position of the pixel in cartesian system on
    // the viewport (but as pixels)
    double x = col - x0;
    double y = y0 - row;
    // Convert the pixel values to viewport system
    double vx = x * delta_x;
    double vy = y * delta_y;
    vec3 vpoint = up * vy + right * vx + direction * focal_length;
    return Ray(position, vpoint - position);
}

void RegularCamera::debug_info(std::ostream &os)
{
    os << "Camera debug info" << std::endl;
    os << "******************" << std::endl;
    os << "Up: " << up << std::endl;
    os << "Right: " << right << std::endl;
    os << "Direction: " << direction << std::endl;
    os << "Position: " << position << std::endl;
    os << "Focal length: " << focal_length << std::endl;
    os << "FOV: " << fov << std::endl;
    os << "Image width: " << image_width << std::endl;
    os << "Image height: " << image_height << std::endl;
    os << "Aspect ratio: " << aspect_ratio << std::endl;
    os << "Viewport width: " << viewport_width << std::endl;
    os << "Viewport height: " << viewport_height << std::endl;
    os << "******************" << std::endl;
}#include "image.hpp"
// #define STB_IMAGE_IMPLEMENTATION
// #include "stb_image.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
void write_to_file(const std::string &filename, image img)
{
    size_t height = img.size();
    size_t width = (img.empty()) ? 0 : img[0].size();
    uint8_t *data = static_cast<uint8_t *>(malloc(width * height * CHANNELS));
    if (data == NULL)
    {
        // Note: TODO: Try to save the float pixel data before exiting to save
        // the rendered image.
        std::cerr << "Error while allocating memory for image!\n";
        exit(1);
    }
    memset(data, 0, width * height * CHANNELS);

    for (size_t i = 0; i < height; ++i)
    {
        for (size_t j = 0; j < width; ++j)
        {
            data[(i * width + j) * CHANNELS] =
                static_cast<uint8_t>((int)(SCALE_FACTOR * img[i][j].r) % 256);
            data[(i * width + j) * CHANNELS + 1] =
                static_cast<uint8_t>((int)(SCALE_FACTOR * img[i][j].g) % 256);
            data[(i * width + j) * CHANNELS + 2] =
                static_cast<uint8_t>((int)(SCALE_FACTOR * img[i][j].b) % 256);
        }
    }
    stbi_write_png(filename.c_str(), width, height, CHANNELS, data,
                   width * CHANNELS);
    free(data);
}
#include "camera.hpp"
#include "colors.hpp"
#include "image.hpp"
#include "progressbar.hpp"
#include "scene.hpp"
#include <iostream>

const int image_width = 400;
const int image_height = 225;
const int PROGRESSBAR_WIDTH = 40;

int main()
{
    int k = 0;
    int max_val = image_height;
    RegularCamera cam(image_width, image_height);
    Scene scene;
    cam.debug_info(std::cout);
    // TODO: Set VT terminal when compiling on windows
    progressbar_hide_cursor();
    progressbar_display(std::cout, k, max_val, PROGRESSBAR_WIDTH);
    try
    {
        image img(image_height, image_row(image_width, colorf()));
        for (int i = 0; i < image_height; ++i)
        {
            for (int j = 0; j < image_width; ++j)
            {
                img[i][j] = scene.color_at(cam.get_ray(i, j), i, j, image_width,
                                           image_height);
            }
            ++k;
            progressbar_display(std::cout, k, max_val, PROGRESSBAR_WIDTH);
        }
        std::cout << std::endl;
        progressbar_show_cursor();
        std::cout << "Writing to disk....." << std::endl;
        write_to_file("output.png", img);
    }
    catch (const std::exception &e)
    {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    return 0;
}#include "objects.hpp"

Sphere::Sphere() : center(vec3(0, 0, 0)), radius(0) {}
Sphere::Sphere(vec3 center, double radius) : center(center), radius(radius) {}

std::vector<double> Sphere::intersection(const Ray &ray) const
{
    vec3 AC = ray.origin() - center;
    double a = linalg::dot(ray.direction(), ray.direction());
    double b = 2.0 * linalg::dot(ray.direction(), AC);
    double c = linalg::dot(AC, AC) - radius * radius;
    double discriminant = b * b - 4 * a * c;
    double sqd = std::sqrt(discriminant);
    if (discriminant < 0)
    {
        // No intersection points
        return std::vector<double>();
    }
    else
    {
        // Return the intersection point of the sphere with the ray
        std::vector<double> result(2, 0);
        result[0] = (-b - sqd) / (2.0 * a);
        result[1] = (-b + sqd) / (2.0 * a);
        return result;
    }
}#include "progressbar.hpp"

void progressbar_display(std::ostream &os, int value, int max_value, int width,
                         bool display_percent)
{
    char fill = '=';
    char head = '>';
    char left_end = '[';
    char right_end = ']';

    os << "\r" << left_end;
    double percent = (double)value / max_value;
    os << std::string(percent * width, fill) << head
       << std::string((1 - percent) * width, ' ') << right_end;
    if (display_percent)
    {
        printf("( %0.2f%% )", percent * 100);
    }
    os << std::flush;
}
#include "ray.hpp"

Ray::Ray(const vec3 &p, const vec3 &d, bool normalized) : rorigin(p)
{
    if (normalized)
    {
        rdirection = d;
    }
    else
    {
        rdirection = linalg::normalize(d);
    }
}

Ray::Ray() : rorigin(), rdirection() {}
vec3 Ray::direction() const { return rdirection; }
vec3 Ray::origin() const { return rorigin; }
vec3 Ray::at(double t) const { return rorigin + (t * rdirection); }#include "scene.hpp"

Scene::Scene()
{
    objects.push_back(std::make_shared<Sphere>(vec3(0, 0, -1), 0.5));
}

colorf Scene::color_at(const Ray &ray, int row, int col, int image_width,
                       int image_height)
{
    colorf result;
    for (const auto &obj : objects)
    {
        // TODO: Handle multiple objects, with one object in front of another
        auto i = obj->intersection(ray);
        if (!i.empty())
        {
            // TODO: Make the code shape independent (by making normal a method
            // of the object)
            vec3 unit = linalg::normalize(ray.at(i[0]) - vec3(0, 0, -1));
            return colorf(0.5 * (unit.x + 1), 0.5 * (unit.y + 1),
                          0.5 * (unit.z + 1));
        }
    }
    double t = double(row) / (image_height - 1);
    return lerp(SKY_COLOR, LIGHT_SKY, t);
}